# @Transactional

### 트랜잭션?

- **데이터베이스의 상태를 변경**하는 작업 또는 **한번에 수행되어야 하는 연산들**을 의미한다
- **begin, commit**을 자동으로 수행해준다
- 예외 발생 시 **rollback** 처리를 자동으로 수행해준다
- 트랜잭션은 4가지의 성질을 가지고 있다

### 트랜잭션의 4가지 성질

**원자성**

- 한 트랜잭션 내에서 실행한 작업들은 하나의 단위로 처리한다. 즉, 모두 성공 또는 모두 실패

**일관성**

- 트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다

**격리성**

- 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야 한다

**영속성**

- 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.

## 트랜잭션 처리 방법

스프링에서는 간단하게 **@Transactional을 메소드, 클래스, 인터페이스** 위에 추가하여 사용하는 방식이 일반적이다. 이 방식을 **선언적 트랜잭션**이라 부르며, 적용된 범위에서는 트랜잭션 기능이 포함된 **프록시 객체가 생성** 되어 자동을 **commit 혹은 rollback을 진행해준다**

### @Transactional의 작동 원리와 흐름

@Transactional이 클래스나 메서드에 붙을 때, Spring은 해당 메서드에 대한 **프록시**를 만든다. 프록시 패턴은 디자인 패턴 중 하나로, 어떤 코드를 감싸면서 추가적인 연산을 수행하도록 강제하는 방법이다. 

트랜잭션의 경우, 트랜잭션의 시작과 연산 종료 시의 커밋 과정이 필요하므로, 프록시를 생성하여 해당 메서드의 앞 뒤에 트랜잭션의 시작과 끝을 추가합니다.  이는 AOP에 바탕을 두고 설계가 되었기 때문에, 이를 `트랜잭션 AOP`라고 하겠다.

 

또한, 스프링 컨테이너는 **트랜잭션 범위의 영속성 컨텍스트 전략**을 기본으로 사용한다. 서비스 클래스에서 @Transactional을 사용할 경우, 해당 코드 내의 메서드를 호출할 때 영속성 컨텍스트가 생긴다. 영속성 컨텍스트는 `트랜잭션 AOP`가 트랜잭션을 시작할 때 생기고, 메서드가 종료되어 트랜잭션 AOP가 트랜잭션을 커밋할 경우 영속성 컨텍스트가 flush 되면서 해당 내용이 반영된다. 이후 영속성 컨텍스트 역시 종료된다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dfb6d5c-1e6d-4d2a-9b00-df40c5431a31/Untitled.png)

[https://velog.io/@kdhyo/JavaTransactional-Annotation-알고-쓰자-26her30h](https://velog.io/@kdhyo/JavaTransactional-Annotation-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-26her30h)

[https://kafcamus.tistory.com/30](https://kafcamus.tistory.com/30)
