# Kafka 브로커

![Part 1: Apache Kafka for beginners - What is Apache Kafka? - CloudKarafka,  Apache Kafka Message streaming as a Service](https://www.cloudkarafka.com/img/blog/kafka-broker-beginner.png)

**카프카 브로커는 일반적으로 '카프카'라고 불리는 시스템을 말합니다.** 
프로듀서와 컨슈머는 별도의 애플리케이션으로 구성되는 반면, 브로커는 **카프카 자체**이기 때문입니다. 
따라서 '카프카를 구성한다' 혹은 '카프카를 통해 메세지를 전달한다'에서 카프카는 브로커를 의미합니다.

**브로커는 카프카 서버**라고도 불립니다.
브로커 내부에 여러 토픽들이 생성될 수 있고, 이러한 토픽들에 의해 생성된 파티션들이 보관하는 데이터에 대해 분산 저장을 해주거나 장애 발생 시, 안전하게 데이터를 사용할 수 있도록 도와주는 역할을 합니다. 


## 카프카 클러스터 구성

![Kafka의 사육사](https://ichi.pro/assets/images/max/724/1*c-NitozGuevoN-rYY8Jwew.png)

**브로커는 한 대 이상의 노드로 클러스터를 구성할 수 있습니다**
클러스터 구성을 위해 브로커의 여러가지 **메타 정보를 저장 관리해주는 Zookeeper**가 필요합니다. 
따라서 카프카를 구성할 때는 한 대 이상의 Zookeeper로 구성된 Zookeeper 클러스터와 한 대 이상의 브로커로 구성된 Kafka 클러스터로 구성됩니다.


### 주키퍼 역할
**컨트롤러 선정**
- 파티션 관리를 책임지는 브로커인 컨트롤러를 선정합니다. 
- 컨트롤러는 파티션의 리더 선정, 토픽 생성, 파티션 생성, 복제본 관리 등을 합니다. 
- 리더 파티션에 장애가 발생하면 팔로워 브로커 중 하나를 리더로 선출 후, 선출한 리더를 다른 브로커들에게 알립니다. 

**브로커 메타데이터**
- 카프카 클러스터 안의 모든 브로커에 대한 상태 정보를 기록합니다.
- 프로듀서와 컨슈머는 주키퍼를 통해 브로커의 상태 정보를 얻습니다.

**토픽 메타 데이터**
- 주키퍼는 파티션 수, 특정한 설정 파라미터 등 토픽 메타데이터를 기록합니다.

**클라이언트 할당 정보**
- 토픽의 메시지를 읽고 쓰는 클라이언트에 대한 바이트 비율의 임계값 제한하며, 모든 정보와 상태는 주키퍼가 관리합니다.


## 주요 브로커 설정

브로커는 여러 환경에 따라 다양한 설정을 할 수 있는데, 대부분의 설정은 기본값이 제공됩니다. 따라서 별도로 설정해주지 않아도 되지만 **아래 3가지 설정은 반드시 해줘야 합니다.**

- broker.id : **같은 카프카 클러스터에서 현재 브로커를 식별하기 위한 숫자입니다**. 따라서 다른 브로커와 다른 숫자를 설정해야 합니다.
- log.dirs : **브로커가 프로듀서로부터 받는 메시지들을 저장할 위치 경로를 지정하는 설정입니다**. 기본 값은 /tmp/kafka-logs입니다. 여기서 주의할 점은 기본값이 /tmp/ 하위에 지정되므로 OS 설정에 따라 삭제 될 수 있으므로 별도로 위치 지정을 해줘야 합니다.
- zookeeper.connect : **카프카 클러스터의 메타 정보를 저장할 zookeeper에 관한 호스트 연결 정보입니다.**


이 외의 추가 설정 정보들입니다.

- advertised.listeners : 클라이언트가 브로커를 바라볼 때의 브로커 호스트 정보입니다.
- auto.create.topics.enable : 클라이언트가 특정 토픽으로 요청했을 경우 자동 생성 여부 설정입니다. (default : true)
- offsets.topic.replication.factor : 오프셋 토픽의 복제 개수 (default :3)

![Kafka Listeners - Explained](https://rmoff.net/images/2018/08/docker01.png)

**브로커는 하나 이상의 리스터를 통해 외부 요청을 받습니다.** 
advertised.listeners
- 클라이언트가 브로커에게 요청할 때, **클라이언트 입장에서 브로커를 찾을 수 있는 호스트 정보를 설정합니다.** 
- 이 설정은 초기 메타 데이터 전달 과정에서 클라이언트로 전달되고, 이 정보를 바탕으로 클라이언트가 브로커로 요청합니다.  여기서 중요한 것은 **클라이언트와 브로커의 네트워크 환경이 다를 경우, 클라이언트가 브로커를 찾을 수 있도록 설정해줘야 한다는 것입니다.**

auto.create.topics.enable
- 운영 과정에서 중요한 설정으로, 실제 상용 환경에서 브로커는 무수히 많은 클라이언트와 맞이하게 됩니다. 
- **이 설정을 true로 하면 클라이언트의 요청에 따라 토픽이 지속적으로 생성됩니다.**

offset.topic.replication.factor
- offset 토픽의 복제 개수에 관한 설정인데, 만약 브로커를 1대로 구성하면 기본값인 3과 충돌하여 브로커가 실행되지 않습니다. 
- 복제 파티션들은 같은 브로커에 존재할 수 없으므로, **개발 환경에서 1대로 구성할 경우 반드시 1로 설정해야 합니다.**

replica.lag.time.max.ms
- 리더는 팔로워들이 주기적으로 데이터를 확인하는지 체크합니다. 해당 설정 이상 확인하지 않을 경우 팔로워를 ISR 그룹에서 제거합니다.
- default = 10000ms = 10초


## 브로커 내부 동작

카프카 브로커는 프로듀서로부터 메시지를 발행 받아 저장하고, 컨슈머로부터 소비됩니다. 이 과정을 위해 브로커 내부에 다양한 동작 요소들이 존재하는데, 간단히 살펴보겠습니다.

### 컨트롤러 (Controller)
컨트롤러는 하나의 클러스터에서 하나의 브로커에 부여되는 역할로 **브로커들을 관리**합니다.
브로커가 정상적인 상태인지 확인 후 임의의 브로커가 중단되었을 경우, 해당 브로커에 있었던 **리더 파티션을 탈락 시키고 다른 팔로워 파티션들 중 하나를 리더로 뽑습니다.** 이 과정은 카프카의 실패 극복 전략 중 중요한 부분을 담당하기 때문에 컨트롤러의 역할은 매우 중요합니다. 참고로 컨트롤러가 중단되는 경우에 Zookeeper가 이를 감지하여 새로운 컨트롤러를 선출합니다. 

-> 컨트롤러 및 리더 선출 과정에 대해서는 나중에 좀 더 자세히 알아보도록 하겠습니다.
https://devidea.tistory.com/71


### 코디네이터 (Coordinator)
코디네이터는 클러스터의 여러 브로커 중 하나의 브로커가 코디네이터 역할을 합니다.
**코디네이터는 컨슈머 그룹의 상태를 체크하여 컨슈머 그룹 내의 컨슈머가 장애가 발생하여 매칭 된 파티션의 데이터를 소비할 수 없게 된 경우 장애가 발생한 컨슈머에게 매칭 된 파티션을 정상 동작하는 다른 컨슈머에게 매칭하여 줍니다.** 
이때, 파티션을 컨슈머에게 재 할당하는 과정을 리밸런싱(Rebalancing)이라고 합니다.


### 메시지 저장과 메시지 파일 관리
브로커는 프로듀서로부터 전달되는 **메시지를 로그 자료구조 형태로 디스크에 저장합니다. **
로그 자료구조는 새로운 쓰기 작업이 중간에 삽입되지 않고 끝에서만 되는 append-only 특징을 가집니다. 
여기서 중요한 것은 쓰기 작업이 끝에서만 이뤄지므로 **브로커에 이미 쓰여진 메시지는 변경이 불가합니다.**
![](https://blog.kakaocdn.net/dn/dkKtMU/btqC2szqNDt/QowXvRgKUAEzQfz282wa1k/img.png)

메시지가 브로커에 저장 될 때는 **메시지의 내용과 함께 오프셋 정보가 저장됩니다. ** 메시지의 오프셋은 메시지를 구분하는 식별자 역할을 하며, 0부터 꾸준히 증가합니다. 


