# 오답(데이터베이스)



1. 데이터베이스 정의에 해당하는 내용을 모두 나열한 것은?

   ㄱ) Shared Data

   ㄴ) Distributed Data

   ㄷ) Stored Data

   ㄹ) Operational Data



> 공용(Shared) 데이터 : 동일 데이터에 대한 중복 최소화
>
> 저장(Stored) 데이터 : 컴퓨터가 접근할 수 있는 기억장치에 저장된 데이터
>
> 운영(Operational) 데이터 : 존재 목적이 명확하고 유용성을 지닌 데이터
>
> 통함(Integrated) 데이터 : 여러 사용자가 다른 목적으로 사용하는 공유 가능한 데이터 





2. DBMS의 필수 기능 중 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능은?
   - Definition 기능
   - Control 기능
   - Manipulation 기능
   - Strategy 기능



> 조작 기능(Manipulation Facility) - 사용자가 데이터를 검색하고 삽입, 삭제, 갱신 등 데이터 처리를 할 수 있는 인터페이스 기능
>
> 정의 기능(Definition Facility) - 데이터베이스에 저장된 데이터의 타입과 구조, 제약조건 등을 명시하는 기능
>
> 제어 기능(Control Facility) - 데이터의 정확성과 안정성을 유지하기 위한 무결성 관리와 병행제어, 접근 제어 등의 기능을 제공





3. DCL 명령어 분류 중 지정된 저장점부터 현재까지 일부만 회복이 가능한 명령어는 무엇인가?
   - COMMIT
   - ROLLBACK
   - SAVEPOINT
   - REVOKE



> COMMIT - 수행결과를 실제 물리적 디스크로 저장
>
> ROLLBACK - 명령 수행 실패를 의미하며 수행된 결과를 원복시킴
>
> SAVEPOINT - 저장된 지점, 지정된 저장점부터 현재까지 일부만 ROLLBACK 기능
>
> GRANT - 데이터베이스 사용자에게 권한 부여
>
> REVOKE - 데이터베이스 사용자게에 부여된 사용 권한 취소



4. 다음은 데이터베이스 SQL의 부분범위 처리 구문이다. 괄호한에 들어갈 알맞은 명령어를 쓰시오

   ```sql
   SELECT ITEM_NM
   FROM ITEM_TAB_HIST
   WHERE (      )
   	(SELECT 'X'
       FROM ITEM_TAB
       WHERE DEPT='101' AND SEQ > 100)
   ```

   - EXISTS
   - ORDER BY
   - HAVING
   - GROUP BY



> SQL 부분범위 처리 목적
>
> - 스캔범위를 나누어 운반단위를 가능한 빨리 채워서 처리 속도 향상
> - 일부분만 처리하고도 Optimizer의 특성을 이용하여 정확한 결과를 도출
> - 처리 범위가 넓더라도 빠른 속도를 얻도록
>
> 



5. 트랜잭션의 특징으로 옳은 내용을 모두 나열?

   ```
   ㄱ) Automicity
   ㄴ) Durability
   ㄷ) Consistency
   ㄹ) Isolation
   ```



> Automicity - 원자성
> Durability - 영속성
> Consistency - 일관성
> Isolation - 고립성



6. 병행 제어 기법을 적용하지 않을 경우의 문제점 중 하나의 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상은?
   - Lost Update
   - Inconsistency
   - Cascading Rollback
   - Uncommitted Dependency



> Lost update(갱신 내용 손실) - 트랜잭션이 동일 데이터를 동시에 갱신할 경우 발생하는 문제. 한 트랜잭션이 데이터를 갱신한 후 트랜잭션을 종료하기 전에 다른 트랜잭션이 그 갱신 값을 또 다시 갱신하는 경우 발생
>
> Dirty Read(오류 데이터 읽기, 현황 파악 오류) - 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조함으로써 발생하는 오류
>
> Inconsistency(모순성) - 두 트랜잭션이 동시에 실행할 때 DB과 일관성이 없는 모순 상태로 남는 문제. 복수의 사용자가 동시에 DB를 Access하여 갱신함으로써 데이터들의 값이 상호일치하지 않거나 모순이 발생하는 경우
>
> Cascading Rollback(연쇄 복귀), Unrecoverability(회복 불능) - 복수의 트랜잭션이 Data 공유 시 특정 트랜잭션이 실패하여 롤백하려해도 다른 트랜잭션이 이미 처리한 부분에 대해서는 최소 불가한 상태가 발생하여 또는 트랜잭션이 연쇄적으로 취소하는 경우 발생
>
> **Uncommitted Dependency(비완료 의존성)** - 낮은 단계의 고립성에서 발생 가능한 문제점(**Dirty Read라고도 한다**).  트랜잭션의 중간값의 데이터 참조하는 현상



7. 로킹 단위가 큰 경우에 대한 설명으로 옳은 것은?
   - 로킹 오버헤드 증가, 데이터베이스 공유도 저하
   - 로킹 오버헤드 감소, 데이터베이스 공유도 저하
   - 로킹 오버헤드 감소, 데이터베이스 공유도 증가
   - 로킹 오버헤드 증가, 데이터베이스 공유도 증가



> 로킹(Locking) - 데이터베이스 관리에서 **하나의 트랜잭션에 사용되는 데이터를 다른 트랜잭션이 접근하지 못하게 하는 것**
>
> 로킹 단위는 병행제어에서 한번에 잠금 할 수 있는 단위로 **데이터베이스, 테이블, 레코드, 필드 등**에 사용된다
>
> - 로킹 단위가 **크면 로킹 수가 작아져 관리가 쉽지만 공유성이 낮아진다**
> - 로킹 단위가 **작으면 로킹 수가 많아 관리가 어렵지만 공유성 수준이 높아진다**
>
> 병행제어 기법
>
> - 2단계 로킹 기법
> - 검증 기법
> - 타임 스탬프 기법



8. 트랜잭션들을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업은?
   - Recovery
   - Restart
   - Commit
   - Abort



> Restart - 데이터베이스 재기동 시 수행하는 작업
>
> Commit - 하나의 논리적 단위에 대한 작업이 성공적으로 끝나고, 데이터베이스가 일관된 상태에 있을 때 트랜잭션이 수행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
>
> Abort - 트랜잭션이 실패한 후 실행되기 이전으로 복귀된 상태



9. 데이터베이스 로그(log)를 필요로 하는 회복 기법은?
   - 즉시 갱신 기법
   - 대수적 코딩 방법
   - 타임 스탬프 기법
   - 폴딩 기법



> 로그 기반 회복 기법은 **즉시 또는 지연 갱신 기법**이다
>
> 지연 갱신(Deferred Update) - 트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 기법
>
> 즉시 갱신(Immediate Update) - 트랜잭션이 데이터를 변경하면 트랜잭션이 부분완료되기 전이라도 즉시 실제 데티어베이스에 반영
>
> 그림자 페이지(Shadow Paging) - 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본을 별도 보관 후, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업 수행
>
> 검사점(Check Point) - 시스템 장애가 발생하였을 경우 검사점 이후 장애 발생 이전에 완료된 경우 Undo 수행, 장애 발생 시점까지 완료하지 못한 경우 Redo 수행
>
> 미디어 회복(Media Recovery) - 디스크 장애가 발생하면 가장 최근의 덤프 내용을 디스크에 적재 후 로그를 이용하여 가장 최근 덤프 이후 완료된 트랜잭션에 대해 redo 작업 수행



10. 뷰에 대한 쿼리문으로 옳지 않은 것은?
    - CREATE VIEW 뷰A AS select * from 테이블 A;
    - DELETE VIEW 뷰 A;
    - SELECT * FROM 뷰A;
    - CREATE VIEW 뷰A AS select * from 테이블A a, 테이블B b where a, 컬럼1=b, 컬럼1;



> view는 delete가 아닌 drop 명령어 사용



--------

1) ㄱ,ㄷ,ㄹ 2) 3, 3) 3, 4) 1, 5) ㄱ,ㄴ,ㄷ,ㄹ 6) 4, 7) 2, 8) 1, 9) 1, 10) 2