# 디자인 패턴

- 각 모듈의 세분화 된 역할이나 모듈들 간의 인터페이스와 같으 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식

- 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 효율적

- **한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화된다**

- GoF 디자인 패턴

  - 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개

  ```
  아키텍처 패턴 VS 디자인 패턴
  - 아키택처 패턴 : 디자인 패턴보다 상위 수준의 설계에 사용
  - 아키택처 패턴 : 전체 시스템 구조를 설계하기 위한 참조 모델
  - 디자인 패턴 : 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
  ```



#### 생성 패턴(Creational Pattern)

- **객체의 생성과 참조 과정을 캡슐화** 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 크게 영향 받지 않도록 **유연성**을 더한다
  - 추상 팩토리(Abstract Factory)
    - 구체적인 클래스에 의존하지 않고, **인터페이스를 통해 서로 연관, 의존**하는 객체들의 그룹으로 생성하여 추상적으로 표현
    - **연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능**
  - 빌더(Builder)
    - 작게 분리된 인스턴스를 건축하듯이 조합하여 객체 생성
    - 동일한 객체 생성에도 **서로 다른 결과를 만들 수 있다**
  - 팩토리 메서드(Factory Method)
    - **객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화**
    - 상위 클래스에서 **인터페이스만 정의**하고 **실제 생성은** **서브 클래스가 담당**
  - 프로토타입(Prototype)
    - **원본 객체를 복제**하여 객체 생성
    - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 사용
  - 싱글톤(Singleton)
    - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없다
    - **클래스 내에서 인스턴스가 하나뿐임을 보장**
    - **불필요한 메모리 낭비를 최소화**



#### 구조 패턴(Structural Pattern)

- 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
  - 어댑터(Adapter)
    - **호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 해주는 패턴**
    - 기존 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 사용
  - 브리지(Bridge)
    - 구현부에서 추상층을 분리하여 **서로가 독립적으로 확장 할 수 있도록 구성한 패턴**
    - 기능과 구현을 **두개의 별도 클래스로 구현**
  - 컴포지트(Composite)
    - 여러 객체를 가진 복합 객체와 단일 객체를 구분없이 다루고자 할 때 사용
    - **복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있다**
  - 데코레이터(Decorator)
    - **객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴**
    - 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식
  - 퍼싸드(Facade)
    - 복잡한 서브 클래스들을 피해 더 **상위 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있는 패턴**
    - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체 필요
  - 플라이웨이트(Flyweight)
    - 인스턴스가 필요할 때마다 매번 생성하는 것이 아닌 **가능한 공유해서 사용하는 패턴**
    - 메모리 절약
    - 다수의 유사 객체를 생성하거나 조작 시 유용
  - 프록시(Proxy)
    - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할하는 객체
    - 네트워크 연결, 메모리 대용량 객체로의 접근에 주로 사용



#### 행위 패턴(Behavioral Pattern)

- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의
  - 책임 연쇄(Chain of Responsibility)
    - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 **한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴**
    - 요청을 처리할 수 있는 객체들이 고리(Chain)로 연결되어 있어 요청이 해결될때까지 고리를 따라 책임 넘긴다
  - 커맨드(Command)
    - 요청을 **캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴**
    - 추상클래스와 구체 클래스로 분리하여 단순화
  - 인터프리터(Interpreter)
    - 언어에 문법 표현을 정의하는 패턴
    - SQL이나 통신 프로토콜 등을 개발할 때 사용
  - 반복자(Iterator)
    - 자료 구조와 같이 **접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴**
    - **내부 표현 방법의 노출 없이 순차적 접근 가능**
  - 중재자(Mediator)
    - 객체들 간의 **복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴**
    - **객체 사이의 의존성을 줄여 결합도를 낮춘다**
  - 메멘토(Memento)
    - **특정 시점에서 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공**
    - ctrl+z 같은 되돌리기 기능 구현 시 주로 사용
  - 옵서버(Observer)
    - **한 객체의 상태가 변하면 객체에 상속되어 있는 다른 객체들에게 변화의 상태를 전달하는 패턴**
  - 상태(State)
    - 객체의 **상태에 따라 동일한 동작을 다르게 처리해야 할 경우 사용**
    - 객체 상태를 캡슐화하고 이를 참조
  - 전략(Strategy)
    - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 하는 패턴
    - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용 가능
  - 템플릿 메서드(Template Method)
    - 상위 클래스에서 **골격 정의**, 하위 클래스에서 **세부 처리를 구체화**
    - **유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에 제공**함으로써 **코드 양 줄이고 유지보수 용이하게 함**
  - 방문자(Visitor)
    - 각 클래스들의 데이터 구조에서 **처리 기능을 분리하여 별도의 클래스로 구성하는 패턴**
    - 분리된 처리 기능은 각 클래스를 방문하여 수행