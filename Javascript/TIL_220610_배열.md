# 배열

순서가 있는 컬렉션을 저장할 때 사용하는 자료구조입니다.

### 배열 선언

```jsx
let arr = new Array();
let arr = [];
```

대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것도 가능합니다. 

```jsx
let fruits = ["사과", "오렌지", "자두"];
```

각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있습니다. 

배열 내 특정 요소를 얻고 싶다면 대괄호 안에 순서를 나타내는 숫자인 인덱스를 넣어주면 됩니다. 

```jsx
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두 
```

동일한 방법으로 요소를 수정할 수 있습니다

```jsx
fruits[2] = '배'; // ["사과","배","자두"]
```

새로운 요소를 추가할 수 있습니다.

```jsx
fruits[3] = '레몬'; // ["사과", "오렌지", "배", "레몬"]으로 바뀜
```

`length`를 사용하여 배열이 담긴 요소가 몇 개인지 알아낼 수 있습니다.

```jsx
let fruits = ["사과", "오렌지", "자두"];
alert(fruits.length);  // 3
```

`alert`를 사용하여 요소 전체를 출력할 수 있습니다.

```jsx
let fruits = ["사과", "오렌지", "자두"];
alert(fruits); // 사과,오렌지,자두
```

배열 요소의 자료형엔 제약이 없습니다.

```jsx
// 요소에 여러 가지 자료형이 섞여 있습니다.
let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다.
alert( arr[1].name ); // 이보라

// 인덱스가 3인 요소(함수)를 실행합니다.
arr[3](); // 안녕하세요.
```

### pop/push와 shift/unshift

큐(queue)는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는데 사용합니다.  

큐에서 사용하는 주요 연산은 아래와 같습니다.

- `push` - 맨 끝에 요소를 추가합니다
- `shift` - 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어줍니다. (두 번째 요소가 첫 번째 요소가 됩니다)

배열엔 두 연산을 가능하게 해주는 내장 메서드 `push`와 `pop`이 있습니다.

배열은 큐 이외에도 스택(stack)이라 불리는 자료구조를 구현할 때도 쓰입니다.

스택에서 사용하는 연산은 아래와 같습니다.

- `push` - 요소를 스택 끝에 집어넣습니다.
- `pop` - 스택 끝 요소를 추출합니다

스택을 사용하면 가장 나중에 집어넣은 요소가 먼저 나옵니다. 

자바 스크립트 배열을 사용하면 큐와 스택을 모두 만들 수 있습니다. 

이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에선 데큐(dequeue, Double Ended Queue)라고 부릅니다. 

**pop**

배열 끝 요소를 제거하고, 제거한 요소를 반환합니다.

```jsx
let fruits = ["사과", "오렌지", "배"];
alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.
alert( fruits ); // 사과,오렌지
```

**push**

배열 끝에 요소를 추가합니다.

```jsx
let fruits = ["사과", "오렌지"];
fruits.push("배");
alert( fruits ); // 사과,오렌지,배
```

**shift**

배열 앞 요소를 제거하고, 제거한 요소를 반환합니다.

```jsx
let fruits = ["사과", "오렌지", "배"];
alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.
alert( fruits ); // 오렌지,배
```

**unshift**

배열 앞에 요소를 추가합니다.

```jsx
let fruits = ["오렌지", "배"];
fruits.unshift('사과');
alert( fruits ); // 사과,오렌지,배
```

### 배열의 내부 동작 원리

배열은 특별한 종류의 객체입니다. 배열은 키가 **숫자**입니다. 

숫자형 키를 사용함으로써 배열은 객체 기본 기능 이외에도 순서가 있는 컬렉션을 제어하게 해주는 메서드를 제공합니다. `length`라는 프로퍼티 또한 제공합니다. 어쨌든 배열의 본질은 객체입니다.

```jsx
let fruits = ["바나나"]
let arr = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)

alert( arr === fruits ); // true

arr.push("배"); // 참조를 이용해 배열을 수정합니다.
alert( fruits ); // 바나나,배 - 요소가 두 개가 되었습니다.
```

배열을 배열답게 만들어주는 것은 특수 내부 표현 방식입니다. 

자바스크립트 엔진은 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높입니다. 이 방법 외에도 배열 관련 연산을 더 빠르게 해주는 최적화 기법은 다양합니다.

만약 배열을 ‘순서가 있는 자료의 컬렉션’처럼 다루지 않고 일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않습니다. 

```jsx
let fruits = []; // 빈 배열을 하나 만듭니다.

fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만듭니다.

fruits.age = 25; // 임의의 이름을 사용해 프로퍼티를 만듭니다.
```

배열은 객체이므로 위와 같이 원하는 프로퍼티를 추가해도 문제가 발생하지 않지만, 자바스크립트 엔진이 배열을 일반 객체처럼 다루게 되어 배열을 다룰 때 적용되는 최적화 기법이 동작하지 않아 배열의 이점이 사라집니다 

아래와 같은 방법을 사용하면 배열의 이점을 사용할 수 없습니다

- `arr.test=5` 같이 숫자가 아닌 값을 프로퍼티 키로 사용할 경우
- `arr[0]`과 `arr[100]`만 추가하고 그 사이에 아무런 요소도 없는 경우
- `arr[10000],arr[999]`와 같이 요소를 역순으로 채우는 경우

배열은 **순서가 있는 자료**를 저장하는 용도로 만들어진 특수한 자료구조입니다. 

자바스크립트 엔진은 이러한 특성을 고려하여 배열을 신중하게 조정하고, 처리하므로 배열을 사용할 땐 이런 목적에 맞게 사용하는 것이 좋습니다. 

임의의 키를 사용해야 한다면 배열보단 일반 객체 `{}`가 적합한 자료구조일 확률이 높습니다. 

### 성능

`push`와 `pop`은 빠르지만 `shift`와 `unshift`는 느립니다.

배열 앞에 무언가를 해주는 메서드가 배열 끝에 무언가를 해주는 메서드보다 느린 이유를 실행 흐름을 살펴보며 알아봅시다. 

`shift` 연산 동작 순서

1. 인덱스가 `0`인 요소를 제거합니다
2. 모든 요소를 왼쪽으로 이동시킵니다.
3. `length` 프로퍼티 값을 갱신합니다. 

**배열에 요소가 많으면 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아집니다.** 

`unshift`를 실행했을 때도 이와 유사한 일이 일어납니다. 

`pop` 메서드는 요소를 옮기지 않으므로 각 요소는 기존 인덱스를 그대로 유지합니다. 배열 긑에 무언가 해주는 메서드의 실행 속도가 빠른 이유는 바로 여기에 있습니다. 

### 반복문

`for`문은 배열을 순회할 때 쓰는 가장 오래된 방법입니다. 

```jsx
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

배열에 적용할 수 있는 또 다른 순회 문법은 `for..of`가 있습니다.

```jsx
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행합니다.
for (let fruit of fruits) {
  alert( fruit );
}
```

배열은 객체에도 속하기 때문에 `for..in`을 사용할 수도 있습니다. 

```jsx
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```

그러나 `for..in`은 아래의 특성을 지니기 때문에 배열에 `for..in`을 사용하면 문제가 발생하기 때문에 되도록 다른 반복문을 사용하는 것이 좋습니다.

1. `for..in` 반복문은 **모든 프로퍼티**를 대상으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함됩니다. 
브라우저나 기타 호스트 환경에서 쓰이는 객체 중, *배열*과 유사한 형태를 보이는 ‘유사 배열’ 객체가 있는데 유사 배열 객체는 배열처럼 `length` 프로퍼티도 있고 요소마다 인덱스도 붙어 있습니다. 그러나 이에 더해 유사 배열 객체엔 배열과는 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있습니다. 
유사 배열 객체와 `for..in`을 함께 사용하면 모든 대상으로 순회가 이뤄지므로 ‘필요 없는’ 프로퍼티들이 문제를 일으킬 수 있습니다. 
2. `for..in`은 배열이 아닌 객체와 함께 사용될 때 최적화 되어 있어 배열에서 사용하면 객체에 사용하는 것 대비 10~100배 정도 느립니다. `for..in` 반복문의 속도가 대체로 빠른 편이기 때문에 병목 지점에서만 문제되긴 하지만, `for..in` 반복문을 사용할 땐 이런 점을 알고 사용하는 것이 좋습니다. 

### length 프로퍼티

배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신됩니다. `length` 프로퍼티는 배열 내 요소 개수가 아니라 가장 큰 인덱스에 1을 더한 값입니다. 

따라서 배열에 요소가 하나 있고, 이 요소의 인덱스가 아주 큰 정수라면 배열의 `length` 프로퍼티도 아주 커집니다. 

```jsx
let fruits = [];
fruits[123] = "사과";

alert( fruits.length ); // 124
```

`length` 프로퍼티의 또 다른 특징 중 하나는 **쓰기가 가능하다**는 것입니다. 

`length` 값을 수동으로 증가 시키면 아무 일도 일어나지 않습니다. 그러나 값을 감소 시키면 배열이 잘립니다. 짧아진 배열은 다시 되돌릴 수 없습니다.

```jsx
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 잘라봅시다.
alert( arr ); // [1, 2]

arr.length = 5; // 본래 길이로 되돌려 봅시다.
alert( arr[3] ); // undefined: 삭제된 기존 요소들이 복구되지 않습니다.
```

이러한 특징을 이용하면 `arr.length=0;`을 사용하면 아주 간단하게 배열을 비울 수 있습니다. 

### new Array()

`new Array()` 문법을 사용하여 배열을 만들 수 있습니다. 

```jsx
let arr = new Array("사과","배","기타");
```

대괄호[] 를 사용하면 더 짧게 배열을 만들 수 있기 때문에 잘 사용되지 않습니다. 

또한 `new Array()`는 다루기 까다로운 기능이 있는데, *숫자형* 인수 하나를 넣어서 `new Array`를 호출하면 배열이 만들어지는데, 이 배열엔 ***요소가 없는 반면 길이는 인수와 같아**집니다.* 

`new Array()`를 사용하면 아래와 같은 실수를 할 수 있습니다. 

```jsx
let arr = new Array(2); 
alert( arr[0] ); // undefined. 요소가 하나도 없는 배열 생성
alert( arr.length ); // 2. 길이는 2입니다.
```

### 다차원 배열
```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, 중심에 있는 요소
```
