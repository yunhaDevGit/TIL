# 심볼형

자바스크립트는 객체 프로퍼티 키로 오직 문자형과 심볼형만을 허용합니다. 숫자형, 불린형 모두 불가능하고 오직 문자형과 심볼형만 가능합니다. 

### 심볼

‘심볼(symbol)’은 유일한 식별자를 만들고 싶을 때 사용합니다. 

`Symbol()`을 사용하면 심볼값을 만들 수 있습니다.

```jsx
let id = Symbol(); // id는 새로운 심볼이 됩니다.
```

심볼을 만들 때 이름이라 불리는 설명을 붙일 수도 있습니다.  심볼 이름은 디버깅 시 아주 유용합니다. 

```jsx
let id = Symbol("id"); // 심볼 id에는 "id"라는 설명이 붙습니다.
```

심볼은 유일성이 보장되는 자료형이므로 설명이 동일한 심볼을 여러 개 만들어도 각 심볼값은 다릅니다. 심볼에 붙이는 설명은 어떤 것에도 영향을 주지 않는 이름표 역할입니다. 

```jsx
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
```

- 심볼은 문자형으로 자동 형 변환되지 않습니다.
    
    ```jsx
    let id = Symbol("id임");
    alert(id); // TypeError: cannot convert a Symbol value to a String
    ```
    
    심볼을 출력해줘야 하는 경우 `.toString()` 메서드를 명시적으로 호출해줘야 합니다. 
    
    ```jsx
    let id = Symbol("id임");
    alert(id.toString()); // Symbol(id)
    alert(id.description); // id임
    ```
    

### ‘숨김’ 프로퍼티

심볼을 이용하면 ‘숨김(hidden)’ 프로퍼티를 만들 수 있습니다. 숨김 프로퍼티는 **외부 코드에서 접근이 불가능하고 값도 덮어쓸 수 없는 프로퍼티**입니다.

서드파티 코드에서 가지고 온 `user`라는 객체가 여러 개 있고, `user`를 이용하여 어떤 작업을 한다고 가정해보겠습니다. 

```jsx
let user = { // 서드파티 코드에서 가져온 객체
  name: "John"
};

let id = Symbol("id");
user[id] = 1;

alert( user[id] ); // 심볼을 키로 사용해 데이터에 접근할 수 있습니다.
```

위의 코드에서 문자열 `"id"`를 키로 사용해도 되는데 `Symbol("id")`를 사용한 이유가 뭘까요?

`user`는 서드파티 코드에서 가지고 온 객체이므로 함부로 새로운 프로퍼티를 추가할 수 없습니다. 그러나 심볼은 서드파티 코드에서 접근할 수 없기 때문에, 심볼을 사용하면 서드파티 코드가 모르게 `user`에 식별자를 부여할 수 있습니다. 

추가로 상황 하나를 더 가정해봅시다.

 제 3의 스크립트(자바스크립트 라이브러리 등)에서 `user`를 식별해야 하는 상황에서 `user`의 원천인 서드파티 코드, 현재 작성 중인 스크립트, 제3의 스크립트가 각자 서로 코드를 모른 채 `user`를 식별해야 하는 상황이 있습니다. 

제3의 스크립트에선 아래와 같이 `Symbol("id")`를 이용하여 전용 식별자를 만들어 사용할 수 있습니다. 

```jsx
// ...
let id = Symbol("id");
user[id] = "제3 스크립트 id 값";
```

→ 심볼은 유일성이 보장되므로 이름이 같더라도 우리가 만든 식별자와 제3의 스크립트에서 만든 식별자가 충돌하지 않습니다. 

만약 아래와 같이 심볼 대신 문자열 “id”를 사용해 식별자를 만들었다면 충돌이 발생할 가능성이 있습니다. 

```jsx
let user = { name: "John" };

// 문자열 "id"를 사용해 식별자를 만들었습니다.
user.id = "스크립트 id 값";

// 만약 제3의 스크립트가 우리 스크립트와 동일하게 문자열 "id"를 이용해 식별자를 만들었다면...

user.id = "제3 스크립트 id 값"
// 의도치 않게 값이 덮어 쓰여서 우리가 만든 식별자는 무의미해집니다.
```

### Symbol in a literal

객체 리터럴 `{...}`을 사용해 객체를 만든 경우, 대괄호를 사용해 심볼형 키를 만들어야 합니다. 

```jsx
let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // "id": 123은 안됨
};
```

`“id”: 123`이라고 하면, 심볼 `id`가 아닌 문자열 “id”가 키가 됩니다. 

### 심볼은 for…in에서 배제됩니다.

키가 심볼인 프로퍼티는 `for...in` 반복문에서 배제됩니다. 

`Object.keys()`에서도 키가 심볼인 프로퍼티는 배제됩니다. 

그러나 `Object.assign`은 키가 심볼인 프로퍼티를 배제하지 않고 객체 내 모든 프로퍼티를 복사합니다. 

### 전역 심볼

심볼은 이름이 같더라도 모두 별개로 취급됩니다. 그런데 이름이 같은 심볼이 같은 개체를 가리키길 원하는 경우도 가끔 있습니다. 

이러한 경우를 위해 *전역 심볼 레지스트리*가 있습니다. 전역 심볼 레지스트리 안에 심볼을 만들고 해당 심볼에 접근하면, 이름이 같은 경우 항상 동일한 심볼을 반환해줍니다. 

레지스트리 안에 심볼을 읽거나, 새로운 심볼을 생성하려면 `Symbol.for(key)`를 사용하면 됩니다. 

```jsx
// 전역 레지스트리에서 심볼을 읽습니다.
let id = Symbol.for("id"); // 심볼이 존재하지 않으면 새로운 심볼을 만듭니다.

// 동일한 이름을 이용해 심볼을 다시 읽습니다(좀 더 멀리 떨어진 코드에서도 가능합니다).
let idAgain = Symbol.for("id");

// 두 심볼은 같습니다.
alert( id === idAgain ); // true
```

### Symbol.keyFor

전역 심볼을 찾을 때 사용되는 `Symbol.for(key)`에 반대되는 메서드도 있습니다. 

`Symbol.keyFor(sym)`을 사용하면 이름을 얻을 수 있습니다. 

```jsx
// 이름을 이용해 심볼을 찾음
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// 심볼을 이용해 이름을 얻음
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

전역 심볼이 아닌 모든 심볼은 `description` 프로퍼티가 있습니다. 일반 심볼에서 이름을 얻고 싶으면 `description` 프로퍼티를 사용하면 됩니다.
