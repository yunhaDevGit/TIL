

### 클래스를 설계할 때 생각할 것

- 객체에서 아는 것 -> 인스턴스 변수
  - **인스턴스**란 **객체**를 부르는 다른 이름
- 객체에서 하는 것 -> 메소드



### 점 연산자

.(점) 연산자는 객체의 상태와 행동(인스턴스 변수와 메소드)을 접근할 수 있게 해주는 역할이다.





### Main 메소드

main 메소드의 두가지 용도

- 클래스를 테스트 하기 위한 용도
- 자바 애플리케이션을 시작하기 위한 용도





### 가비지 컬렉터

자바는 청소도 알아서 한다

- 자바 객체가 만들어지면 힙(Heap)이라는 메모리 공간에 저장된다. 

  모든 객체는 힙에 있다. (가비지 컬렉션 기능이 있는 힙)

  객체가 만들어지면 그 객체의 크기에 따라 힙 안에 적당한 메모리 공간을 할당한다.

- 어떤 객체가 더 이상 필요 없을 때 메모리 관리를 자동으로 처리해준다

  JVM에서 어떤 객체가 다시 쓰이지 않는다고 결론을 내리면 그 객체는 가비지 컬렉션 대상이 된다. 그리고 매모리가 모자라면 가비지 컬렉터가 작동하면서 더이상 사용할 수 없는 객체를 치워 재활용할 수 있는 메모리 공간을 확보한다. 



----------

##### 전역 변수나 전역 메소드는 어떻게?

- 자바에는 전역 변수나 메소드의 개념이 없지만, 어디서든지 쓸 수 있는 메소드를 만들 수 있다
- 메소드를 public 그리고 static으로 지정을 하면 전역 메소드와 비슷하게 사용할 수 있다.



##### 전역 함수나 전역 데이터를 만드는데 어떻게 객체지향적이라고 할 수 있지?

- 자바의 모든 것이 클래스 안에 있다. 

- static(정적)인 것들은 자바에서 비교적 예외...

  (이런 변수와 메소드는 인스턴스/객체 여러 개에 들어가지 않는 매우 특별한 경우에 해당)



##### 클래스가 수백, 수천개면 어떻게 전달? 하나의 애플리케이션 형태로 만들 수 없나?

- 자바 아카이브(.jar)  하나에 넣을 수 있다.
- jar 파일에 manifest라는 간단히 포메팅 된 텍스트 파일이 있는데 jar에 들어있는 파일 중 어떤 파일을 실행시켜야 할 지(어떤 파일에 main() 메소드가 있는지) 알려주는 내용이 있다.



--------

### 핵심 정리

- 객체지향적인 프로그래밍을 하면 제작과 테스트 과정이 끝난 코드를 건드리지 않고도 프로그램을 확장할 수 있다.
- 모든 자바 코드는 **클래스 내**에서 정의된다.
- 클래스는 해당 클래스 유형의 객체를 만드는 방법을 설명하는 역할을 한다. 
- 객체는 각자 알아서 자기 할 일을 처리할 수 있다. 사용자는 객체에서 작업을 처리하는 방법에 대해 신경 쓰지 않아도 된다.
- 객체에는 **알고 있는 것(인스턴스)**과 **할 수 있는 것(메소드)**이 있다.
- 객체가 자기 자신에 대해 알고 있는 것을 **인스턴스 변수**라고 하고, 객체의 상태를 나타낸다.
- 객체가 할 수 있는 것을 **메소드**라고 부르고 객체의 행동을 나타낸다.
- 클래스를 새로 만들 때는 그 클래스 유형의 객체를 만들어서 테스트하는 테스트용 클래스를 따로 만들어 보는 것이 좋다. 
- 클래스에서 **덜 구체적인 상위 클래스**로부터 인스턴스 변수와 메소드를 **상속**할 수 있다.
- 프로그램을 실행시킬 때 보면 자바 프로그램이란 결국 다른 객체와 대화를 하는 객체에 불과하다. 



-----------



### 클래스, 객체, 인스턴스 변수, 메소드

- .java 파일을 컴파일 하면 만들어진다 -> 클래스
- 내 인스턴스 변수의 값은 다른 친구의 값과 다를 수 있다 -> 객체
- 템플릿 같은 역할을 한다 -> 클래스
- 뭔가 하는 것을 좋아한다 -> 객체, 메소드
- 메소드 여러개를 가질 수 있다 -> 객체, 클래스
- '상태'를 나타낸다 -> 인스턴스 변수
- 특정 행동을 할 수 있다 -> 객체, 클래스
- 객체 안에 들어있다 -> 인스턴스 변수, 메소드
- 힙 안에 산다 -> 객체
- 객체 인스턴스를 만들기 위한 용도 -> 클래스
- 메소드를 선언한다 -> 클래스
- 실행 중에 바뀔 수 있다 -> 인스턴스 변수, 객체